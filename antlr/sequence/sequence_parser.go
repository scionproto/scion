// File generated by ANTLR. DO NOT EDIT.

package sequence // Sequence
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SequenceParser struct {
	*antlr.BaseParser
}

var SequenceParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func sequenceParserInit() {
	staticData := &SequenceParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'0'", "", "", "", "", "'#'", "','", "'?'", "'+'", "'*'", "'|'",
		"'('", "')'",
	}
	staticData.SymbolicNames = []string{
		"", "WHITESPACE", "ZERO", "NUM", "WILDCARDAS", "LEGACYAS", "AS", "HASH",
		"COMMA", "QUESTIONMARK", "PLUS", "ASTERISK", "OR", "LPAR", "RPAR",
	}
	staticData.RuleNames = []string{
		"start", "sequence", "onehop", "isd", "as", "iface",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 14, 71, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3,
		1, 22, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 5, 1, 35, 8, 1, 10, 1, 12, 1, 38, 9, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3,
		2, 56, 8, 2, 1, 3, 1, 3, 3, 3, 60, 8, 3, 1, 4, 1, 4, 1, 4, 3, 4, 65, 8,
		4, 1, 5, 1, 5, 3, 5, 69, 8, 5, 1, 5, 0, 1, 2, 6, 0, 2, 4, 6, 8, 10, 0,
		0, 77, 0, 12, 1, 0, 0, 0, 2, 21, 1, 0, 0, 0, 4, 55, 1, 0, 0, 0, 6, 59,
		1, 0, 0, 0, 8, 64, 1, 0, 0, 0, 10, 68, 1, 0, 0, 0, 12, 13, 3, 2, 1, 0,
		13, 14, 5, 0, 0, 1, 14, 1, 1, 0, 0, 0, 15, 16, 6, 1, -1, 0, 16, 17, 5,
		13, 0, 0, 17, 18, 3, 2, 1, 0, 18, 19, 5, 14, 0, 0, 19, 22, 1, 0, 0, 0,
		20, 22, 3, 4, 2, 0, 21, 15, 1, 0, 0, 0, 21, 20, 1, 0, 0, 0, 22, 36, 1,
		0, 0, 0, 23, 24, 10, 4, 0, 0, 24, 25, 5, 12, 0, 0, 25, 35, 3, 2, 1, 5,
		26, 27, 10, 3, 0, 0, 27, 35, 3, 2, 1, 4, 28, 29, 10, 7, 0, 0, 29, 35, 5,
		9, 0, 0, 30, 31, 10, 6, 0, 0, 31, 35, 5, 10, 0, 0, 32, 33, 10, 5, 0, 0,
		33, 35, 5, 11, 0, 0, 34, 23, 1, 0, 0, 0, 34, 26, 1, 0, 0, 0, 34, 28, 1,
		0, 0, 0, 34, 30, 1, 0, 0, 0, 34, 32, 1, 0, 0, 0, 35, 38, 1, 0, 0, 0, 36,
		34, 1, 0, 0, 0, 36, 37, 1, 0, 0, 0, 37, 3, 1, 0, 0, 0, 38, 36, 1, 0, 0,
		0, 39, 56, 3, 6, 3, 0, 40, 41, 3, 6, 3, 0, 41, 42, 3, 8, 4, 0, 42, 56,
		1, 0, 0, 0, 43, 44, 3, 6, 3, 0, 44, 45, 3, 8, 4, 0, 45, 46, 5, 7, 0, 0,
		46, 47, 3, 10, 5, 0, 47, 56, 1, 0, 0, 0, 48, 49, 3, 6, 3, 0, 49, 50, 3,
		8, 4, 0, 50, 51, 5, 7, 0, 0, 51, 52, 3, 10, 5, 0, 52, 53, 5, 8, 0, 0, 53,
		54, 3, 10, 5, 0, 54, 56, 1, 0, 0, 0, 55, 39, 1, 0, 0, 0, 55, 40, 1, 0,
		0, 0, 55, 43, 1, 0, 0, 0, 55, 48, 1, 0, 0, 0, 56, 5, 1, 0, 0, 0, 57, 60,
		5, 2, 0, 0, 58, 60, 5, 3, 0, 0, 59, 57, 1, 0, 0, 0, 59, 58, 1, 0, 0, 0,
		60, 7, 1, 0, 0, 0, 61, 65, 5, 4, 0, 0, 62, 65, 5, 5, 0, 0, 63, 65, 5, 6,
		0, 0, 64, 61, 1, 0, 0, 0, 64, 62, 1, 0, 0, 0, 64, 63, 1, 0, 0, 0, 65, 9,
		1, 0, 0, 0, 66, 69, 5, 2, 0, 0, 67, 69, 5, 3, 0, 0, 68, 66, 1, 0, 0, 0,
		68, 67, 1, 0, 0, 0, 69, 11, 1, 0, 0, 0, 7, 21, 34, 36, 55, 59, 64, 68,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SequenceParserInit initializes any static state used to implement SequenceParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSequenceParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SequenceParserInit() {
	staticData := &SequenceParserStaticData
	staticData.once.Do(sequenceParserInit)
}

// NewSequenceParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSequenceParser(input antlr.TokenStream) *SequenceParser {
	SequenceParserInit()
	this := new(SequenceParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SequenceParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Sequence.g4"

	return this
}

// SequenceParser tokens.
const (
	SequenceParserEOF          = antlr.TokenEOF
	SequenceParserWHITESPACE   = 1
	SequenceParserZERO         = 2
	SequenceParserNUM          = 3
	SequenceParserWILDCARDAS   = 4
	SequenceParserLEGACYAS     = 5
	SequenceParserAS           = 6
	SequenceParserHASH         = 7
	SequenceParserCOMMA        = 8
	SequenceParserQUESTIONMARK = 9
	SequenceParserPLUS         = 10
	SequenceParserASTERISK     = 11
	SequenceParserOR           = 12
	SequenceParserLPAR         = 13
	SequenceParserRPAR         = 14
)

// SequenceParser rules.
const (
	SequenceParserRULE_start    = 0
	SequenceParserRULE_sequence = 1
	SequenceParserRULE_onehop   = 2
	SequenceParserRULE_isd      = 3
	SequenceParserRULE_as       = 4
	SequenceParserRULE_iface    = 5
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sequence() ISequenceContext
	EOF() antlr.TerminalNode

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_start
	return p
}

func InitEmptyStartContext(p *StartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_start
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SequenceParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Sequence() ISequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceContext)
}

func (s *StartContext) EOF() antlr.TerminalNode {
	return s.GetToken(SequenceParserEOF, 0)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitStart(s)
	}
}

func (p *SequenceParser) Start_() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SequenceParserRULE_start)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(12)
		p.sequence(0)
	}
	{
		p.SetState(13)
		p.Match(SequenceParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceContext is an interface to support dynamic dispatch.
type ISequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSequenceContext differentiates from other interfaces.
	IsSequenceContext()
}

type SequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceContext() *SequenceContext {
	var p = new(SequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_sequence
	return p
}

func InitEmptySequenceContext(p *SequenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_sequence
}

func (*SequenceContext) IsSequenceContext() {}

func NewSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceContext {
	var p = new(SequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SequenceParserRULE_sequence

	return p
}

func (s *SequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceContext) CopyAll(ctx *SequenceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type OrContext struct {
	SequenceContext
}

func NewOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrContext {
	var p = new(OrContext)

	InitEmptySequenceContext(&p.SequenceContext)
	p.parser = parser
	p.CopyAll(ctx.(*SequenceContext))

	return p
}

func (s *OrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrContext) AllSequence() []ISequenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceContext); ok {
			len++
		}
	}

	tst := make([]ISequenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceContext); ok {
			tst[i] = t.(ISequenceContext)
			i++
		}
	}

	return tst
}

func (s *OrContext) Sequence(i int) ISequenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceContext)
}

func (s *OrContext) OR() antlr.TerminalNode {
	return s.GetToken(SequenceParserOR, 0)
}

func (s *OrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterOr(s)
	}
}

func (s *OrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitOr(s)
	}
}

type ConcatenationContext struct {
	SequenceContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	InitEmptySequenceContext(&p.SequenceContext)
	p.parser = parser
	p.CopyAll(ctx.(*SequenceContext))

	return p
}

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) AllSequence() []ISequenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISequenceContext); ok {
			len++
		}
	}

	tst := make([]ISequenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISequenceContext); ok {
			tst[i] = t.(ISequenceContext)
			i++
		}
	}

	return tst
}

func (s *ConcatenationContext) Sequence(i int) ISequenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type QuestionMarkContext struct {
	SequenceContext
}

func NewQuestionMarkContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuestionMarkContext {
	var p = new(QuestionMarkContext)

	InitEmptySequenceContext(&p.SequenceContext)
	p.parser = parser
	p.CopyAll(ctx.(*SequenceContext))

	return p
}

func (s *QuestionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuestionMarkContext) Sequence() ISequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceContext)
}

func (s *QuestionMarkContext) QUESTIONMARK() antlr.TerminalNode {
	return s.GetToken(SequenceParserQUESTIONMARK, 0)
}

func (s *QuestionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterQuestionMark(s)
	}
}

func (s *QuestionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitQuestionMark(s)
	}
}

type HopContext struct {
	SequenceContext
}

func NewHopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HopContext {
	var p = new(HopContext)

	InitEmptySequenceContext(&p.SequenceContext)
	p.parser = parser
	p.CopyAll(ctx.(*SequenceContext))

	return p
}

func (s *HopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HopContext) Onehop() IOnehopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnehopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnehopContext)
}

func (s *HopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterHop(s)
	}
}

func (s *HopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitHop(s)
	}
}

type PlusContext struct {
	SequenceContext
}

func NewPlusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PlusContext {
	var p = new(PlusContext)

	InitEmptySequenceContext(&p.SequenceContext)
	p.parser = parser
	p.CopyAll(ctx.(*SequenceContext))

	return p
}

func (s *PlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlusContext) Sequence() ISequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceContext)
}

func (s *PlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SequenceParserPLUS, 0)
}

func (s *PlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterPlus(s)
	}
}

func (s *PlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitPlus(s)
	}
}

type AsteriskContext struct {
	SequenceContext
}

func NewAsteriskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AsteriskContext {
	var p = new(AsteriskContext)

	InitEmptySequenceContext(&p.SequenceContext)
	p.parser = parser
	p.CopyAll(ctx.(*SequenceContext))

	return p
}

func (s *AsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsteriskContext) Sequence() ISequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceContext)
}

func (s *AsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SequenceParserASTERISK, 0)
}

func (s *AsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterAsterisk(s)
	}
}

func (s *AsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitAsterisk(s)
	}
}

type ParenthesesContext struct {
	SequenceContext
}

func NewParenthesesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesesContext {
	var p = new(ParenthesesContext)

	InitEmptySequenceContext(&p.SequenceContext)
	p.parser = parser
	p.CopyAll(ctx.(*SequenceContext))

	return p
}

func (s *ParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesesContext) LPAR() antlr.TerminalNode {
	return s.GetToken(SequenceParserLPAR, 0)
}

func (s *ParenthesesContext) Sequence() ISequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceContext)
}

func (s *ParenthesesContext) RPAR() antlr.TerminalNode {
	return s.GetToken(SequenceParserRPAR, 0)
}

func (s *ParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterParentheses(s)
	}
}

func (s *ParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitParentheses(s)
	}
}

func (p *SequenceParser) Sequence() (localctx ISequenceContext) {
	return p.sequence(0)
}

func (p *SequenceParser) sequence(_p int) (localctx ISequenceContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSequenceContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISequenceContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 2
	p.EnterRecursionRule(localctx, 2, SequenceParserRULE_sequence, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(21)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SequenceParserLPAR:
		localctx = NewParenthesesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(16)
			p.Match(SequenceParserLPAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(17)
			p.sequence(0)
		}
		{
			p.SetState(18)
			p.Match(SequenceParserRPAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SequenceParserZERO, SequenceParserNUM:
		localctx = NewHopContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(20)
			p.Onehop()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(36)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(34)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
			case 1:
				localctx = NewOrContext(p, NewSequenceContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SequenceParserRULE_sequence)
				p.SetState(23)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(24)
					p.Match(SequenceParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(25)
					p.sequence(5)
				}

			case 2:
				localctx = NewConcatenationContext(p, NewSequenceContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SequenceParserRULE_sequence)
				p.SetState(26)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(27)
					p.sequence(4)
				}

			case 3:
				localctx = NewQuestionMarkContext(p, NewSequenceContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SequenceParserRULE_sequence)
				p.SetState(28)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(29)
					p.Match(SequenceParserQUESTIONMARK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 4:
				localctx = NewPlusContext(p, NewSequenceContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SequenceParserRULE_sequence)
				p.SetState(30)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(31)
					p.Match(SequenceParserPLUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 5:
				localctx = NewAsteriskContext(p, NewSequenceContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SequenceParserRULE_sequence)
				p.SetState(32)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(33)
					p.Match(SequenceParserASTERISK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(38)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnehopContext is an interface to support dynamic dispatch.
type IOnehopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOnehopContext differentiates from other interfaces.
	IsOnehopContext()
}

type OnehopContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnehopContext() *OnehopContext {
	var p = new(OnehopContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_onehop
	return p
}

func InitEmptyOnehopContext(p *OnehopContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_onehop
}

func (*OnehopContext) IsOnehopContext() {}

func NewOnehopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnehopContext {
	var p = new(OnehopContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SequenceParserRULE_onehop

	return p
}

func (s *OnehopContext) GetParser() antlr.Parser { return s.parser }

func (s *OnehopContext) CopyAll(ctx *OnehopContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OnehopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnehopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ISDASHopContext struct {
	OnehopContext
}

func NewISDASHopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ISDASHopContext {
	var p = new(ISDASHopContext)

	InitEmptyOnehopContext(&p.OnehopContext)
	p.parser = parser
	p.CopyAll(ctx.(*OnehopContext))

	return p
}

func (s *ISDASHopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ISDASHopContext) Isd() IIsdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsdContext)
}

func (s *ISDASHopContext) As() IAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsContext)
}

func (s *ISDASHopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterISDASHop(s)
	}
}

func (s *ISDASHopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitISDASHop(s)
	}
}

type ISDASIFIFHopContext struct {
	OnehopContext
}

func NewISDASIFIFHopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ISDASIFIFHopContext {
	var p = new(ISDASIFIFHopContext)

	InitEmptyOnehopContext(&p.OnehopContext)
	p.parser = parser
	p.CopyAll(ctx.(*OnehopContext))

	return p
}

func (s *ISDASIFIFHopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ISDASIFIFHopContext) Isd() IIsdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsdContext)
}

func (s *ISDASIFIFHopContext) As() IAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsContext)
}

func (s *ISDASIFIFHopContext) HASH() antlr.TerminalNode {
	return s.GetToken(SequenceParserHASH, 0)
}

func (s *ISDASIFIFHopContext) AllIface() []IIfaceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIfaceContext); ok {
			len++
		}
	}

	tst := make([]IIfaceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIfaceContext); ok {
			tst[i] = t.(IIfaceContext)
			i++
		}
	}

	return tst
}

func (s *ISDASIFIFHopContext) Iface(i int) IIfaceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfaceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfaceContext)
}

func (s *ISDASIFIFHopContext) COMMA() antlr.TerminalNode {
	return s.GetToken(SequenceParserCOMMA, 0)
}

func (s *ISDASIFIFHopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterISDASIFIFHop(s)
	}
}

func (s *ISDASIFIFHopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitISDASIFIFHop(s)
	}
}

type ISDHopContext struct {
	OnehopContext
}

func NewISDHopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ISDHopContext {
	var p = new(ISDHopContext)

	InitEmptyOnehopContext(&p.OnehopContext)
	p.parser = parser
	p.CopyAll(ctx.(*OnehopContext))

	return p
}

func (s *ISDHopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ISDHopContext) Isd() IIsdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsdContext)
}

func (s *ISDHopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterISDHop(s)
	}
}

func (s *ISDHopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitISDHop(s)
	}
}

type ISDASIFHopContext struct {
	OnehopContext
}

func NewISDASIFHopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ISDASIFHopContext {
	var p = new(ISDASIFHopContext)

	InitEmptyOnehopContext(&p.OnehopContext)
	p.parser = parser
	p.CopyAll(ctx.(*OnehopContext))

	return p
}

func (s *ISDASIFHopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ISDASIFHopContext) Isd() IIsdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsdContext)
}

func (s *ISDASIFHopContext) As() IAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsContext)
}

func (s *ISDASIFHopContext) HASH() antlr.TerminalNode {
	return s.GetToken(SequenceParserHASH, 0)
}

func (s *ISDASIFHopContext) Iface() IIfaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfaceContext)
}

func (s *ISDASIFHopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterISDASIFHop(s)
	}
}

func (s *ISDASIFHopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitISDASIFHop(s)
	}
}

func (p *SequenceParser) Onehop() (localctx IOnehopContext) {
	localctx = NewOnehopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SequenceParserRULE_onehop)
	p.SetState(55)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		localctx = NewISDHopContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(39)
			p.Isd()
		}

	case 2:
		localctx = NewISDASHopContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(40)
			p.Isd()
		}
		{
			p.SetState(41)
			p.As()
		}

	case 3:
		localctx = NewISDASIFHopContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(43)
			p.Isd()
		}
		{
			p.SetState(44)
			p.As()
		}
		{
			p.SetState(45)
			p.Match(SequenceParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(46)
			p.Iface()
		}

	case 4:
		localctx = NewISDASIFIFHopContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(48)
			p.Isd()
		}
		{
			p.SetState(49)
			p.As()
		}
		{
			p.SetState(50)
			p.Match(SequenceParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(51)
			p.Iface()
		}
		{
			p.SetState(52)
			p.Match(SequenceParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(53)
			p.Iface()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsdContext is an interface to support dynamic dispatch.
type IIsdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIsdContext differentiates from other interfaces.
	IsIsdContext()
}

type IsdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsdContext() *IsdContext {
	var p = new(IsdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_isd
	return p
}

func InitEmptyIsdContext(p *IsdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_isd
}

func (*IsdContext) IsIsdContext() {}

func NewIsdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsdContext {
	var p = new(IsdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SequenceParserRULE_isd

	return p
}

func (s *IsdContext) GetParser() antlr.Parser { return s.parser }

func (s *IsdContext) CopyAll(ctx *IsdContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IsdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WildcardISDContext struct {
	IsdContext
}

func NewWildcardISDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildcardISDContext {
	var p = new(WildcardISDContext)

	InitEmptyIsdContext(&p.IsdContext)
	p.parser = parser
	p.CopyAll(ctx.(*IsdContext))

	return p
}

func (s *WildcardISDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardISDContext) ZERO() antlr.TerminalNode {
	return s.GetToken(SequenceParserZERO, 0)
}

func (s *WildcardISDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterWildcardISD(s)
	}
}

func (s *WildcardISDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitWildcardISD(s)
	}
}

type ISDContext struct {
	IsdContext
}

func NewISDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ISDContext {
	var p = new(ISDContext)

	InitEmptyIsdContext(&p.IsdContext)
	p.parser = parser
	p.CopyAll(ctx.(*IsdContext))

	return p
}

func (s *ISDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ISDContext) NUM() antlr.TerminalNode {
	return s.GetToken(SequenceParserNUM, 0)
}

func (s *ISDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterISD(s)
	}
}

func (s *ISDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitISD(s)
	}
}

func (p *SequenceParser) Isd() (localctx IIsdContext) {
	localctx = NewIsdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SequenceParserRULE_isd)
	p.SetState(59)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SequenceParserZERO:
		localctx = NewWildcardISDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(57)
			p.Match(SequenceParserZERO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SequenceParserNUM:
		localctx = NewISDContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(58)
			p.Match(SequenceParserNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsContext is an interface to support dynamic dispatch.
type IAsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAsContext differentiates from other interfaces.
	IsAsContext()
}

type AsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsContext() *AsContext {
	var p = new(AsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_as
	return p
}

func InitEmptyAsContext(p *AsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_as
}

func (*AsContext) IsAsContext() {}

func NewAsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsContext {
	var p = new(AsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SequenceParserRULE_as

	return p
}

func (s *AsContext) GetParser() antlr.Parser { return s.parser }

func (s *AsContext) CopyAll(ctx *AsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ASContext struct {
	AsContext
}

func NewASContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ASContext {
	var p = new(ASContext)

	InitEmptyAsContext(&p.AsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AsContext))

	return p
}

func (s *ASContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ASContext) AS() antlr.TerminalNode {
	return s.GetToken(SequenceParserAS, 0)
}

func (s *ASContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterAS(s)
	}
}

func (s *ASContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitAS(s)
	}
}

type LegacyASContext struct {
	AsContext
}

func NewLegacyASContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LegacyASContext {
	var p = new(LegacyASContext)

	InitEmptyAsContext(&p.AsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AsContext))

	return p
}

func (s *LegacyASContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LegacyASContext) LEGACYAS() antlr.TerminalNode {
	return s.GetToken(SequenceParserLEGACYAS, 0)
}

func (s *LegacyASContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterLegacyAS(s)
	}
}

func (s *LegacyASContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitLegacyAS(s)
	}
}

type WildcardASContext struct {
	AsContext
}

func NewWildcardASContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildcardASContext {
	var p = new(WildcardASContext)

	InitEmptyAsContext(&p.AsContext)
	p.parser = parser
	p.CopyAll(ctx.(*AsContext))

	return p
}

func (s *WildcardASContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardASContext) WILDCARDAS() antlr.TerminalNode {
	return s.GetToken(SequenceParserWILDCARDAS, 0)
}

func (s *WildcardASContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterWildcardAS(s)
	}
}

func (s *WildcardASContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitWildcardAS(s)
	}
}

func (p *SequenceParser) As() (localctx IAsContext) {
	localctx = NewAsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SequenceParserRULE_as)
	p.SetState(64)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SequenceParserWILDCARDAS:
		localctx = NewWildcardASContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(61)
			p.Match(SequenceParserWILDCARDAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SequenceParserLEGACYAS:
		localctx = NewLegacyASContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(62)
			p.Match(SequenceParserLEGACYAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SequenceParserAS:
		localctx = NewASContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(63)
			p.Match(SequenceParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfaceContext is an interface to support dynamic dispatch.
type IIfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIfaceContext differentiates from other interfaces.
	IsIfaceContext()
}

type IfaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfaceContext() *IfaceContext {
	var p = new(IfaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_iface
	return p
}

func InitEmptyIfaceContext(p *IfaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SequenceParserRULE_iface
}

func (*IfaceContext) IsIfaceContext() {}

func NewIfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfaceContext {
	var p = new(IfaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SequenceParserRULE_iface

	return p
}

func (s *IfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *IfaceContext) CopyAll(ctx *IfaceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IFaceContext struct {
	IfaceContext
}

func NewIFaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IFaceContext {
	var p = new(IFaceContext)

	InitEmptyIfaceContext(&p.IfaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*IfaceContext))

	return p
}

func (s *IFaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IFaceContext) NUM() antlr.TerminalNode {
	return s.GetToken(SequenceParserNUM, 0)
}

func (s *IFaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterIFace(s)
	}
}

func (s *IFaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitIFace(s)
	}
}

type WildcardIFaceContext struct {
	IfaceContext
}

func NewWildcardIFaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildcardIFaceContext {
	var p = new(WildcardIFaceContext)

	InitEmptyIfaceContext(&p.IfaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*IfaceContext))

	return p
}

func (s *WildcardIFaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardIFaceContext) ZERO() antlr.TerminalNode {
	return s.GetToken(SequenceParserZERO, 0)
}

func (s *WildcardIFaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.EnterWildcardIFace(s)
	}
}

func (s *WildcardIFaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SequenceListener); ok {
		listenerT.ExitWildcardIFace(s)
	}
}

func (p *SequenceParser) Iface() (localctx IIfaceContext) {
	localctx = NewIfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SequenceParserRULE_iface)
	p.SetState(68)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SequenceParserZERO:
		localctx = NewWildcardIFaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(66)
			p.Match(SequenceParserZERO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SequenceParserNUM:
		localctx = NewIFaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(67)
			p.Match(SequenceParserNUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SequenceParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 1:
		var t *SequenceContext = nil
		if localctx != nil {
			t = localctx.(*SequenceContext)
		}
		return p.Sequence_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SequenceParser) Sequence_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
