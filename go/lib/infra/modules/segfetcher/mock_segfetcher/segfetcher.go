// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/scionproto/scion/go/lib/infra/modules/segfetcher (interfaces: DstProvider,ReplyHandler,Requester,RequestAPI,Resolver,Splitter,Storage,Validator,Verifier)

// Package mock_segfetcher is a generated GoMock package.
package mock_segfetcher

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	path_mgmt "github.com/scionproto/scion/go/lib/ctrl/path_mgmt"
	segfetcher "github.com/scionproto/scion/go/lib/infra/modules/segfetcher"
	segverifier "github.com/scionproto/scion/go/lib/infra/modules/segverifier"
	net "net"
	reflect "reflect"
)

// MockDstProvider is a mock of DstProvider interface
type MockDstProvider struct {
	ctrl     *gomock.Controller
	recorder *MockDstProviderMockRecorder
}

// MockDstProviderMockRecorder is the mock recorder for MockDstProvider
type MockDstProviderMockRecorder struct {
	mock *MockDstProvider
}

// NewMockDstProvider creates a new mock instance
func NewMockDstProvider(ctrl *gomock.Controller) *MockDstProvider {
	mock := &MockDstProvider{ctrl: ctrl}
	mock.recorder = &MockDstProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDstProvider) EXPECT() *MockDstProviderMockRecorder {
	return m.recorder
}

// Dst mocks base method
func (m *MockDstProvider) Dst(arg0 context.Context, arg1 segfetcher.Request) (net.Addr, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dst", arg0, arg1)
	ret0, _ := ret[0].(net.Addr)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Dst indicates an expected call of Dst
func (mr *MockDstProviderMockRecorder) Dst(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dst", reflect.TypeOf((*MockDstProvider)(nil).Dst), arg0, arg1)
}

// MockReplyHandler is a mock of ReplyHandler interface
type MockReplyHandler struct {
	ctrl     *gomock.Controller
	recorder *MockReplyHandlerMockRecorder
}

// MockReplyHandlerMockRecorder is the mock recorder for MockReplyHandler
type MockReplyHandlerMockRecorder struct {
	mock *MockReplyHandler
}

// NewMockReplyHandler creates a new mock instance
func NewMockReplyHandler(ctrl *gomock.Controller) *MockReplyHandler {
	mock := &MockReplyHandler{ctrl: ctrl}
	mock.recorder = &MockReplyHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockReplyHandler) EXPECT() *MockReplyHandlerMockRecorder {
	return m.recorder
}

// Handle mocks base method
func (m *MockReplyHandler) Handle(arg0 context.Context, arg1 *path_mgmt.SegReply, arg2 net.Addr, arg3 <-chan struct{}) *segfetcher.ProcessedResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Handle", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*segfetcher.ProcessedResult)
	return ret0
}

// Handle indicates an expected call of Handle
func (mr *MockReplyHandlerMockRecorder) Handle(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockReplyHandler)(nil).Handle), arg0, arg1, arg2, arg3)
}

// MockRequester is a mock of Requester interface
type MockRequester struct {
	ctrl     *gomock.Controller
	recorder *MockRequesterMockRecorder
}

// MockRequesterMockRecorder is the mock recorder for MockRequester
type MockRequesterMockRecorder struct {
	mock *MockRequester
}

// NewMockRequester creates a new mock instance
func NewMockRequester(ctrl *gomock.Controller) *MockRequester {
	mock := &MockRequester{ctrl: ctrl}
	mock.recorder = &MockRequesterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRequester) EXPECT() *MockRequesterMockRecorder {
	return m.recorder
}

// Request mocks base method
func (m *MockRequester) Request(arg0 context.Context, arg1 segfetcher.RequestSet) <-chan segfetcher.ReplyOrErr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Request", arg0, arg1)
	ret0, _ := ret[0].(<-chan segfetcher.ReplyOrErr)
	return ret0
}

// Request indicates an expected call of Request
func (mr *MockRequesterMockRecorder) Request(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Request", reflect.TypeOf((*MockRequester)(nil).Request), arg0, arg1)
}

// MockRequestAPI is a mock of RequestAPI interface
type MockRequestAPI struct {
	ctrl     *gomock.Controller
	recorder *MockRequestAPIMockRecorder
}

// MockRequestAPIMockRecorder is the mock recorder for MockRequestAPI
type MockRequestAPIMockRecorder struct {
	mock *MockRequestAPI
}

// NewMockRequestAPI creates a new mock instance
func NewMockRequestAPI(ctrl *gomock.Controller) *MockRequestAPI {
	mock := &MockRequestAPI{ctrl: ctrl}
	mock.recorder = &MockRequestAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRequestAPI) EXPECT() *MockRequestAPIMockRecorder {
	return m.recorder
}

// GetSegs mocks base method
func (m *MockRequestAPI) GetSegs(arg0 context.Context, arg1 *path_mgmt.SegReq, arg2 net.Addr, arg3 uint64) (*path_mgmt.SegReply, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSegs", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*path_mgmt.SegReply)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSegs indicates an expected call of GetSegs
func (mr *MockRequestAPIMockRecorder) GetSegs(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSegs", reflect.TypeOf((*MockRequestAPI)(nil).GetSegs), arg0, arg1, arg2, arg3)
}

// MockResolver is a mock of Resolver interface
type MockResolver struct {
	ctrl     *gomock.Controller
	recorder *MockResolverMockRecorder
}

// MockResolverMockRecorder is the mock recorder for MockResolver
type MockResolverMockRecorder struct {
	mock *MockResolver
}

// NewMockResolver creates a new mock instance
func NewMockResolver(ctrl *gomock.Controller) *MockResolver {
	mock := &MockResolver{ctrl: ctrl}
	mock.recorder = &MockResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockResolver) EXPECT() *MockResolverMockRecorder {
	return m.recorder
}

// Resolve mocks base method
func (m *MockResolver) Resolve(arg0 context.Context, arg1 segfetcher.Segments, arg2 segfetcher.RequestSet) (segfetcher.Segments, segfetcher.RequestSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Resolve", arg0, arg1, arg2)
	ret0, _ := ret[0].(segfetcher.Segments)
	ret1, _ := ret[1].(segfetcher.RequestSet)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Resolve indicates an expected call of Resolve
func (mr *MockResolverMockRecorder) Resolve(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resolve", reflect.TypeOf((*MockResolver)(nil).Resolve), arg0, arg1, arg2)
}

// MockSplitter is a mock of Splitter interface
type MockSplitter struct {
	ctrl     *gomock.Controller
	recorder *MockSplitterMockRecorder
}

// MockSplitterMockRecorder is the mock recorder for MockSplitter
type MockSplitterMockRecorder struct {
	mock *MockSplitter
}

// NewMockSplitter creates a new mock instance
func NewMockSplitter(ctrl *gomock.Controller) *MockSplitter {
	mock := &MockSplitter{ctrl: ctrl}
	mock.recorder = &MockSplitterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSplitter) EXPECT() *MockSplitterMockRecorder {
	return m.recorder
}

// Split mocks base method
func (m *MockSplitter) Split(arg0 context.Context, arg1 segfetcher.Request) (segfetcher.RequestSet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Split", arg0, arg1)
	ret0, _ := ret[0].(segfetcher.RequestSet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Split indicates an expected call of Split
func (mr *MockSplitterMockRecorder) Split(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Split", reflect.TypeOf((*MockSplitter)(nil).Split), arg0, arg1)
}

// MockStorage is a mock of Storage interface
type MockStorage struct {
	ctrl     *gomock.Controller
	recorder *MockStorageMockRecorder
}

// MockStorageMockRecorder is the mock recorder for MockStorage
type MockStorageMockRecorder struct {
	mock *MockStorage
}

// NewMockStorage creates a new mock instance
func NewMockStorage(ctrl *gomock.Controller) *MockStorage {
	mock := &MockStorage{ctrl: ctrl}
	mock.recorder = &MockStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStorage) EXPECT() *MockStorageMockRecorder {
	return m.recorder
}

// StoreRevs mocks base method
func (m *MockStorage) StoreRevs(arg0 context.Context, arg1 []*path_mgmt.SignedRevInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreRevs", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreRevs indicates an expected call of StoreRevs
func (mr *MockStorageMockRecorder) StoreRevs(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreRevs", reflect.TypeOf((*MockStorage)(nil).StoreRevs), arg0, arg1)
}

// StoreSegs mocks base method
func (m *MockStorage) StoreSegs(arg0 context.Context, arg1 []*segfetcher.SegWithHP) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreSegs", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreSegs indicates an expected call of StoreSegs
func (mr *MockStorageMockRecorder) StoreSegs(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreSegs", reflect.TypeOf((*MockStorage)(nil).StoreSegs), arg0, arg1)
}

// MockValidator is a mock of Validator interface
type MockValidator struct {
	ctrl     *gomock.Controller
	recorder *MockValidatorMockRecorder
}

// MockValidatorMockRecorder is the mock recorder for MockValidator
type MockValidatorMockRecorder struct {
	mock *MockValidator
}

// NewMockValidator creates a new mock instance
func NewMockValidator(ctrl *gomock.Controller) *MockValidator {
	mock := &MockValidator{ctrl: ctrl}
	mock.recorder = &MockValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockValidator) EXPECT() *MockValidatorMockRecorder {
	return m.recorder
}

// Validate mocks base method
func (m *MockValidator) Validate(arg0 context.Context, arg1 segfetcher.Request) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validate", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Validate indicates an expected call of Validate
func (mr *MockValidatorMockRecorder) Validate(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockValidator)(nil).Validate), arg0, arg1)
}

// MockVerifier is a mock of Verifier interface
type MockVerifier struct {
	ctrl     *gomock.Controller
	recorder *MockVerifierMockRecorder
}

// MockVerifierMockRecorder is the mock recorder for MockVerifier
type MockVerifierMockRecorder struct {
	mock *MockVerifier
}

// NewMockVerifier creates a new mock instance
func NewMockVerifier(ctrl *gomock.Controller) *MockVerifier {
	mock := &MockVerifier{ctrl: ctrl}
	mock.recorder = &MockVerifierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockVerifier) EXPECT() *MockVerifierMockRecorder {
	return m.recorder
}

// Verify mocks base method
func (m *MockVerifier) Verify(arg0 context.Context, arg1 *path_mgmt.SegReply, arg2 net.Addr) (chan segverifier.UnitResult, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Verify", arg0, arg1, arg2)
	ret0, _ := ret[0].(chan segverifier.UnitResult)
	ret1, _ := ret[1].(int)
	return ret0, ret1
}

// Verify indicates an expected call of Verify
func (mr *MockVerifierMockRecorder) Verify(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Verify", reflect.TypeOf((*MockVerifier)(nil).Verify), arg0, arg1, arg2)
}
