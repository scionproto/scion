# Copyright 2014 ETH Zurich
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
:mod:`trc` --- SCION TRC parser
===============================================
"""
# Stdlib
import base64
import copy
import json
import logging
import os
import time

# External
import lz4

# SCION
from lib.crypto.asymcrypto import verify, sign
from lib.crypto.util import CERT_DIR
from lib.errors import SCIONParseError
from lib.packet.scion_addr import ISD_AS

ISD_STRING = 'ISD'
DESCRIPTION_STRING = 'Description'
VERSION_STRING = 'Version'
CREATION_TIME_STRING = 'CreationTime'
EXPIRATION_TIME_STRING = 'ExpirationTime'
CORE_ASES_STRING = 'CoreASes'
ROOT_CAS_STRING = 'RootCAs'
CERT_LOGS_STRING = 'CertLogs'
THRESHOLD_EEPKI_STRING = 'ThresholdEEPKI'
RAINS_STRING = 'RAINS'
QUORUM_TRC_STRING = 'QuorumTRC'
QUORUM_CAS_STRING = 'QuorumCAs'
GRACE_PERIOD_STRING = 'GracePeriod'
QUARANTINE_STRING = 'Quarantine'
SIGNATURES_STRING = 'Signatures'

ARPKI_KEY_STRING = 'ARPKIKey'
ARPKI_SRV_STRING = 'ARPKISrv'
CERTIFICATE_STRING = 'Certificate'
OFFLINE_KEY_ALG_STRING = 'OfflineKeyAlg'
OFFLINE_KEY_STRING = 'OfflineKey'
ONLINE_KEY_ALG_STRING = 'OnlineKeyAlg'
ONLINE_KEY_STRING = 'OnlineKey'
ROOT_RAINS_KEY_STRING = 'RootRAINSKey'
TRC_SRV_STRING = 'TRCSrv'


def get_trc_file_path(conf_dir, isd, version):  # pragma: no cover
    """
    Return the TRC file path for a given ISD.
    """
    return os.path.join(conf_dir, CERT_DIR, 'ISD%s-V%s.trc' % (isd, version))


class TRC(object):
    """
    The TRC class parses the TRC file of an ISD and stores such
    information for further use.

    :ivar int isd: the ISD identifier.
    :ivar str description: is a human readable description of an ISD.
    :ivar int version: the TRC file version.
    :ivar int create_time: the TRC file creation timestamp.
    :ivar int exp_time: the TRC expiration timestamp.
    :ivar dict core_ases: the set of core ASes and their certificates.
    :ivar dict root_cas: the set of root CAs and their certificates.
    :ivar dict cert_logs: is a dictionary of end entity certificate log servers of
        form {name: {"isd_as IP": pub_key}}
    :ivar int threshold_eepki: is a threshold number (nonnegative integer) of
        CAs that have to sign a domainâ€™s policy
    :ivar dict rains: the RAINS section.
    :ivar int quorum_trc: number of core ASes necessary to sign a new TRC.
    :ivar int quorum_cas: number of CAs necessary to change CA entries
    :ivar int grace_period: defines for how long this TRC is valid when a new
        TRC is available
    :ivar bool quarantine: flag defining whether TRC is valid(quarantine=false)
        or an early announcement(quarantine=true)
    :ivar dict signatures: signatures generated by a quorum of trust roots.
    """

    VALIDITY_PERIOD = 365 * 24 * 60 * 60

    FIELDS_MAP = {
        ISD_STRING: ("isd", int),
        DESCRIPTION_STRING: ("description", str),
        VERSION_STRING: ("version", int),
        CREATION_TIME_STRING: ("create_time", int),
        EXPIRATION_TIME_STRING: ("exp_time", int),
        CORE_ASES_STRING: ("core_ases", dict),
        ROOT_CAS_STRING: ("root_cas", dict),
        CERT_LOGS_STRING: ("cert_logs", dict),
        THRESHOLD_EEPKI_STRING: ("threshold_eepki", int),
        RAINS_STRING: ("rains", dict),
        QUORUM_TRC_STRING: ("quorum_trc", int),
        QUORUM_CAS_STRING: ("quorum_cas", int),
        QUARANTINE_STRING: ("quarantine", bool),
        SIGNATURES_STRING: ("signatures", dict),
        GRACE_PERIOD_STRING: ("grace_period", int),
    }

    MULTI_DICT_DECODE_FIELDS = {
        CORE_ASES_STRING: [ONLINE_KEY_STRING, OFFLINE_KEY_STRING],
        ROOT_CAS_STRING: [CERTIFICATE_STRING, ONLINE_KEY_STRING, ARPKI_KEY_STRING],
    }

    SIMPLE_DICT_DECODE_FIELDS = {
        RAINS_STRING: [ROOT_RAINS_KEY_STRING, ONLINE_KEY_STRING],
        SIGNATURES_STRING: [],
    }

    def __init__(self, trc_dict):
        """
        :param dict trc_dict: TRC as dict.
        """
        for k, (name, type_) in self.FIELDS_MAP.items():
            val = trc_dict[k]
            if type_ in (int,):
                val = int(val)
            elif type_ in (dict, ):
                val = copy.deepcopy(val)
            setattr(self, name, val)

        for attr, decode_list in self.MULTI_DICT_DECODE_FIELDS.items():
            field = getattr(self, self.FIELDS_MAP[attr][0])
            for entry in field.values():
                for key in decode_list:
                    entry[key] = base64.b64decode(entry[key].encode('utf-8'))

        for attr, decode_list in self.SIMPLE_DICT_DECODE_FIELDS.items():
            entry = getattr(self, self.FIELDS_MAP[attr][0])
            if not entry:
                continue
            for key in decode_list or entry:
                entry[key] = base64.b64decode(entry[key].encode('utf-8'))

        for subject, entry in trc_dict[CERT_LOGS_STRING].items():
            try:
                addr, pub_key = next(iter(entry.items()))
                self.cert_logs[subject][addr] = base64.b64decode(pub_key.encode('utf-8'))
            except StopIteration:
                raise SCIONParseError("Invalid CertLogs entry for %s: %s", subject, entry)

    def get_isd_ver(self):
        return self.isd, self.version

    def get_core_ases(self):
        res = []
        for key in self.core_ases:
            res.append(ISD_AS(key))
        return res

    def dict(self, with_signatures):
        """
        Return the TRC information.

        :param bool with_signatures:
            If True, include signatures in the return value.
        :returns: the TRC information.
        :rtype: dict
        """
        trc_dict = {}
        for k, (name, _) in self.FIELDS_MAP.items():
            trc_dict[k] = getattr(self, name)
        if not with_signatures:
            del trc_dict[SIGNATURES_STRING]
        return trc_dict

    @classmethod
    def from_raw(cls, trc_raw, lz4_=False):
        if lz4_:
            trc_raw = lz4.loads(trc_raw).decode("utf-8")
        trc = json.loads(trc_raw)
        return TRC(trc)

    @classmethod
    def from_values(cls, isd, description, version, core_ases, root_cas,
                    cert_logs, threshold_eepki, rains, quorum_trc,
                    quorum_cas, grace_period, quarantine, signatures, validity_period):
        """
        Generate a TRC instance.
        """
        now = int(time.time())
        trc_dict = {
            ISD_STRING: isd,
            DESCRIPTION_STRING: description,
            VERSION_STRING: version,
            CREATION_TIME_STRING: now,
            EXPIRATION_TIME_STRING: now + validity_period,
            CORE_ASES_STRING: core_ases,
            ROOT_CAS_STRING: root_cas,
            CERT_LOGS_STRING: cert_logs,
            THRESHOLD_EEPKI_STRING: threshold_eepki,
            RAINS_STRING: rains,
            QUORUM_TRC_STRING: quorum_trc,
            QUORUM_CAS_STRING: quorum_cas,
            GRACE_PERIOD_STRING: grace_period,
            QUARANTINE_STRING: quarantine,
            SIGNATURES_STRING: signatures,
        }
        trc = TRC(trc_dict)
        return trc

    def sign(self, isd_as, sig_priv_key):
        """
        Sign TRC and add computed signature to the TRC.

        :param ISD_AS isd_as: the ISD-AS of signer.
        :param SigningKey sig_priv_key: the signing key of signer.
        """
        data = self._sig_input()
        self.signatures[str(isd_as)] = sign(data, sig_priv_key)

    def verify(self, old_trc):
        """
        Perform signature verification for core signatures as defined
        in old TRC.

        :param: old_trc: the previous TRC which has already been verified.
        :returns: True if verification succeeds, false otherwise.
        :rtype: bool
        """
        # Only look at signatures which are from core ASes as defined in old TRC
        signatures = {k: self.signatures[k] for k in old_trc.core_ases.keys()}
        # We have more signatures than the number of core ASes in old TRC
        if len(signatures) < len(self.signatures):
            logging.warning("TRC has more signatures than number of core ASes.")
        valid_signature_signers = set()
        # Add every signer to this set whose signature was verified successfully
        for signer in signatures:
            public_key = self.core_ases[signer].subject_sig_key_raw
            if self._verify_signature(signatures[signer], public_key):
                valid_signature_signers.add(signer)
            else:
                logging.warning("TRC contains a signature which could not \
                be verified.")
        # We have fewer valid signatrues for this TRC than quorum_own_trc
        if len(valid_signature_signers) < old_trc.quorum_own_trc:
            logging.error("TRC does not have the number of required valid \
            signatures")
            return False
        logging.debug("TRC verified.")
        return True

    def _verify_signature(self, signature, public_key):
        """
        Checks if the signature can be verified with the given public key for a
        single signature

        :returns: True if the given signature could be verified with the
            given key, False otherwise
        :rtype bool
        """
        if not verify(self._sig_input(), signature, public_key):
            return False
        return True

    def _sig_input(self):
        d = self.dict(False)
        for k in d:
            if self.FIELDS_MAP[k][1] == str:
                d[k] = base64.b64encode(d[k].encode('utf-8')).decode('utf-8')
            elif self.FIELDS_MAP[k][1] == dict:
                d[k] = self._encode_dict(d[k])
        j = json.dumps(d, sort_keys=True, separators=(',', ':'))
        return j.encode('utf-8')

    def _encode_dict(self, dict_):
        encoded_dict = {}
        for key, val in dict_.items():
            if type(val) is dict:
                val = self._encode_sub_dict(val)
            elif type(val) is bytes:
                val = base64.b64encode(val).decode('utf-8')
            encoded_dict[key] = val
        return encoded_dict

    def _encode_sub_dict(self, dict_):
        encoded_dict = {}
        for key, val in dict_.items():
            if type(val) is bytes:
                val = base64.b64encode(val).decode('utf-8')
            encoded_dict[key] = val
        return encoded_dict

    def to_json(self, with_signatures=True):
        """
        Convert the instance to json format.
        """
        trc_dict = copy.deepcopy(self.dict(with_signatures))
        for field, decode_list in self.MULTI_DICT_DECODE_FIELDS.items():
            for entry in trc_dict[field].values():
                for key in decode_list:
                    entry[key] = base64.b64encode(entry[key]).decode('utf-8')
        for field, decode_list in self.SIMPLE_DICT_DECODE_FIELDS.items():
            entry = trc_dict.get(field, None)
            if not entry or (field == SIGNATURES_STRING and not with_signatures):
                continue
            # Every value is decoded, if decode_list is empty
            for key in decode_list or entry:
                entry[key] = base64.b64encode(entry[key]).decode('utf-8')
        cert_logs = {}
        for subject, entry in trc_dict[CERT_LOGS_STRING].items():
            try:
                addr = next(iter(entry.keys()))
                entry[addr] = base64.b64encode(entry[addr]).decode('utf-8')
                cert_logs[subject] = entry
            except StopIteration:
                pass
        trc_dict[CERT_LOGS_STRING] = cert_logs
        trc_str = json.dumps(trc_dict, sort_keys=True, indent=4)
        return trc_str

    def pack(self, lz4_=False):
        ret = self.to_json().encode('utf-8')
        if lz4_:
            return lz4.dumps(ret)
        return ret

    def __str__(self):
        return self.to_json()

    def __eq__(self, other):  # pragma: no cover
        return str(self) == str(other)


def verify_new_trc(old_trc, new_trc):
    """
    Check if update from current TRC to updated TRC is valid. Checks if update
    is correct and checks if the new TRC has enough valid signatures as defined
    in the current TRC.

    :returns: True if update is valid, False otherwise
    """
    # Check if update is correct
    if old_trc.isd != new_trc.isd:
        logging.error("TRC isdid mismatch")
        return False
    if old_trc.version + 1 != new_trc.version:
        logging.error("TRC versions mismatch")
        return False
    if new_trc.time < old_trc.time:
        logging.error("New TRC timestamp is not valid")
        return False
    if new_trc.quarantine or old_trc.quarantine:
        logging.error("Early announcement")
        return False
    # Check if there are enough valid signatures for new TRC
    if not new_trc.verify(old_trc):
        logging.error("New TRC verification failed, missing or \
        invalid signatures")
        return False
    logging.debug("New TRC verified")
    return True
