# Copyright 2014 ETH Zurich
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
:mod:`trc` --- SCION TRC parser
===============================================
"""

# Stdlib
import base64
import copy
import json
import logging
import time

# External
import lz4

# SCION
from lib.crypto.asymcrypto import verify
from lib.crypto.certificate import (
    Certificate,
    SUBJECT_ENC_KEY_STRING,
    SUBJECT_SIG_KEY_STRING,
    SIGNATURE_STRING
)
from lib.packet.scion_addr import ISD_AS

ISDID_STRING = 'ISDID'
VERSION_STRING = 'Version'
TIME_STRING = 'Time'
CORE_ASES_STRING = 'CoreCAs'
ROOT_CAS_STRING = 'RootCAs'
LOGS_STRING = 'Logs'
CA_THRESHOLD_STRING = 'CAThreshold'
ROOT_DNS_SERVERS_STRING = 'RootDNSServers'
ROOT_DNS_CERT_STRING = 'RootDNSCert'
QUORUM_OWN_TRC_STRING = 'QuorumOwnTRC'
QUORUM_CROSS_TRC_STRING = 'QuorumCrossTRC'
QUORUM_CAS_STRING = 'QuorumCAs'
QUROUM_DNS_STRING = 'QuorumDNS'
QUARANTINE_STRING = 'Quarantine'
POLICIES_STRING = 'Policies'
SIGNATURES_STRING = 'Signatures'
GRACE_PERIOD_STRING = 'GracePeriod'

class TRC(object):
    """
    The TRC class parses the TRC file of an ISD and stores such
    information for further use.

    :ivar int isd: the ISD identifier.
    :ivar int version: the TRC file version.
    :ivar int time: the TRC file creation timestamp.
    :ivar int core_quorum: number of trust roots necessary to sign a new TRC.
    :ivar int trc_quorum:
        number of trust roots necessary to sign a new ISD cross-signing
        certificate.
    :ivar dict core_isps: the set of core ISPs and their certificates.
    :ivar dict root_cas: the set of root CAs and their certificates.
    :ivar dict logs: is a dictionary of end entity certificate logs, and
        their addresses and public key certificates
    :ivar int ca_threshold: is a threshold number (nonnegative integer) of
        CAs that have to sign a domainâ€™s policy
    :ivar dict core_ases: the set of core ASes and their certificates.
    :ivar dict policies: additional management policies for the ISD.
    :ivar str registry_server_addr: the root registry server's address.
    :ivar str registry_server_cert: the root registry server's certificate.
    :ivar str root_dns_server_addr: the root DNS server's address.
    :ivar str root_dns_server_cert: the root DNS server's certificate.
    :ivar str trc_server_addr: the TRC server's address.
    :ivar dict signatures: signatures generated by a quorum of trust roots.
    """

    def __init__(self, trc_raw=None):
        """
        :param str trc_raw: TRC as json string.
        """
        self.isd = 0
        self.version = 0
        self.time = 0
        self.core_ases = {}
        self.root_cas = {}
        self.logs = {}
        self.ca_threshold = 0
        self.root_dns_server_addr = ''
        self.root_dns_server_cert = ''
        self.quorum_own_trc = 0
        self.quorum_cross_trc = 0
        self.quorum_cas = 0
        self.quorum_dns = 0
        self.quarantine = False
        self.policies = {}
        self.signatures = {}
        self.grace_period = 0
        if trc_raw:
            self._parse(trc_raw)

    def get_isd_ver(self):
        return self.isd, self.version

    def get_core_ases(self):
        res = []
        for key in self.core_ases:
            res.append(ISD_AS(key))
        return res

    def get_trc_dict(self, with_signatures):
        """
        Return the TRC information.

        :param bool with_signatures:
            If True, include signatures in the return value.
        :returns: the TRC information.
        :rtype: dict
        """
        trc_dict = {
            ISDID_STRING: self.isd,
            VERSION_STRING: self.version,
            TIME_STRING: self.time,
            CORE_ASES_STRING: self.core_ases,
            ROOT_CAS_STRING: self.root_cas,
            LOGS_STRING: self.logs,
            CA_THRESHOLD_STRING: self.ca_threshold,
            ROOT_DNS_SERVERS_STRING: self.root_dns_server_addr,
            ROOT_DNS_CERT_STRING: self.root_dns_server_cert,
            QUORUM_OWN_TRC_STRING: self.quorum_own_trc,
            QUORUM_CROSS_TRC_STRING: self.quorum_cross_trc,
            QUORUM_CAS_STRING: self.quorum_cas,
            QUROUM_DNS_STRING: self.quorum_dns,
            QUARANTINE_STRING: self.quarantine,
            POLICIES_STRING: self.policies,
            GRACE_PERIOD_STRING: self.grace_period}
        if with_signatures:
            trc_dict[SIGNATURES_STRING] = self.signatures
        return trc_dict

    def _parse(self, trc_raw):
        """
        Parse a TRC file and populate the instance's attributes.

        :param str trc_raw: TRC as json string.
        """
        trc = json.loads(trc_raw)
        self.isd = trc[ISDID_STRING]
        self.version = trc[VERSION_STRING]
        self.time = trc[TIME_STRING]
        for subject in trc[CORE_ASES_STRING]:
            cert_dict = base64.b64decode(trc[CORE_ASES_STRING][subject]).\
                decode('utf-8')
            cert_dict = json.loads(cert_dict)
            cert_dict[SUBJECT_SIG_KEY_STRING] = base64.b64decode(
                cert_dict[SUBJECT_SIG_KEY_STRING])
            cert_dict[SUBJECT_ENC_KEY_STRING] = base64.b64decode(
                cert_dict[SUBJECT_ENC_KEY_STRING])
            cert_dict[SIGNATURE_STRING] = base64.b64decode(cert_dict[SIGNATURE_STRING])
            #TODO: ugly, improve this
            isd_ , as_ = subject.split(' ', 1)[1].split(',',1)
            as_ = as_.split(' ', 2)[2].split('}', 1)[0]
            self.core_ases[isd_ + '-' + as_] = Certificate.from_dict(cert_dict)
        self.root_cas = trc[ROOT_CAS_STRING]
        self.logs = trc[LOGS_STRING]
        self.ca_threshold = trc[CA_THRESHOLD_STRING]
        self.root_dns_server_addr = trc[ROOT_DNS_SERVERS_STRING]
        self.root_dns_server_cert = trc[ROOT_DNS_CERT_STRING]
        self.quorum_own_trc = trc[QUORUM_OWN_TRC_STRING]
        self.quorum_cross_trc = trc[QUORUM_CROSS_TRC_STRING]
        self.quorum_cas = trc[QUORUM_CAS_STRING]
        self.quorum_dns = trc[QUROUM_DNS_STRING]
        self.quarantine = trc[QUARANTINE_STRING]
        self.policies = trc[POLICIES_STRING]
        for subject in trc[SIGNATURES_STRING]:
            #TODO: ugly, improve this
            isd_ , as_ = subject.split(' ', 1)[1].split(',',1)
            as_ = as_.split(' ', 2)[2].split('}', 1)[0]
            self.signatures[isd_ + '-' + as_] = \
                base64.b64decode(trc[SIGNATURES_STRING][subject])
        self.grace_period = trc[GRACE_PERIOD_STRING]

    @classmethod
    def from_values(cls, isd, version, core_ases, root_cas, logs, ca_threshold,
                    root_dns_server_addr, root_dns_server_cert, quorum_own_trc,
                    quorum_cross_trc, quorum_cas, quorum_dns, quarantine,
                    policies, signatures, grace_period):
        """
        Generate a TRC instance.
        """
        trc = TRC()
        trc.isd = isd
        trc.version = version
        trc.time = int(time.time())
        trc.core_ases = core_ases
        trc.root_cas = root_cas
        trc.logs = logs
        trc.ca_threshold = ca_threshold
        trc.root_dns_server_addr = root_dns_server_addr
        trc.root_dns_server_cert = root_dns_server_cert
        trc.quorum_own_trc = quorum_own_trc
        trc.quorum_cross_trc = quorum_cross_trc
        trc.quorum_cas = quorum_cas
        trc.quorum_dns = quorum_dns
        trc.quarantine = quarantine
        trc.policies = policies
        trc.signatures = signatures
        trc.grace_period = grace_period
        return trc

    def verify(self, oldTRC):
        """
        Perform signature verification.

        :returns: True if verification succeeds, false otherwise
        """
        return self._verify_core_signatures(oldTRC)

    def verify_xsigs(self, otherTRCs):
        """
        Perform cross signature verification
        otherTRSc is a dict from (ASID, ISDID) to trc

        :returns: True if verification succeeds, false otherwise
        """
        return self._verify_other_signatures(otherTRCs)

    def _verify_core_signatures(self, oldTRC):
        """
        Perform signature verification for core signatures.

        :returns: True if verification succeeds, false otherwise.
        :rtype: bool
        """
        #only look at signatures which are from core ASes
        signatures = {k: self.signatures[k] for k in oldTRC.core_ases.keys()}
        if len(signatures) < len(self.signatures):
            logging.warning("TRC is signed by a non-core AS")
        valid_signature_signers = set()
        for signer in signatures:
            public_key = self.core_ases[signer].subject_sig_key
            if self._verify_signature(signatures[signer], public_key):
                valid_signature_signers.add(signer)
        if len(valid_signature_signers) < self.quorum_own_trc:
            logging.error("TRC does not have the number of required valid " + \
            "signatures. Required Signatures:%s, valid signatures:%s"% \
            (self.quorum_own_trc, len(valid_signature_signers)))
            return False
        if len(valid_signature_signers) < oldTRC.quorum_own_trc:
            logging.error("TRC does not have the number of required valid" + \
            "signatures as defined in old TRC. " + \
            "Required Signatures:%s, valid signatures:%s"% \
            (oldTRC.quorum_own_trc, len(valid_signature_signers)))
            return False
        return True

    def _verify_other_signatures(self, otherTRCs):
        """
        Perform signature verification for signatures of other ISDs.

        :returns: True if verification succeeds, false otherwise.
        :rtype: bool
        """
        #TODO: Check that otherTRSc does not contain signatures from own ISD cores
        # Check signatures
        valid_signature_signers = set()
        for subject in self.signatures:
            otherTRC = otherTRCs[subject]
            public_key = otherTRC.core_ases[subject].subject_sig_key
            # TODO: try-statement here, for the case that subject is not found
            # in core_ases dict
            if _verify_signature(otherTRC.core_ases[subject], public_key):
                valid_signature_signers.add(subject)
        if len(valid_signature_signers) < self.quorum_cross_trc:
            logging.error("TRC does not have the number of required valid" + \
            "cross signatures. Required Signatures:%s, valid signatures:%s"% \
            (self.quorum_cross_trc, len(valid_signature_signers)))
            return False
        return True

    def _verify_signature(self, signature, public_key):
        """
        Checks if the signature can be verified with the given public key
        """
        msg = self.to_json(with_signatures=False).encode('utf-8')
        if not verify(msg, signature, public_key):
            return False
        return True

    def to_json(self, with_signatures=True):
        """
        Convert the instance to json format.
        """
        trc_dict = copy.deepcopy(self.get_trc_dict(with_signatures))
        core_ases = {}
        for subject in trc_dict[CORE_ASES_STRING]:
            isd_as = ISD_AS()
            #TODO: "Private" methods are called here, change this
            isd_as._parse_str(subject)
            subject_string = '{ISDID: ' + str(isd_as._isd) + ', ASID: ' + \
                str(isd_as._as) + '}'
            cert_str = str(trc_dict[CORE_ASES_STRING][subject])
            core_ases[subject_string] = base64.b64encode(
                cert_str.encode('utf-8')).decode('utf-8')
        trc_dict[CORE_ASES_STRING] = core_ases
        if with_signatures:
            signatures = {}
            for subject in trc_dict[SIGNATURES_STRING]:
                isd_as = ISD_AS()
                #TODO: "Private" methods are called here, change this
                isd_as._parse_str(subject)
                subject_string = '{ISDID: ' + str(isd_as._isd) + ', ASID: ' + \
                    str(isd_as._as) + '}'
                signature = trc_dict[SIGNATURES_STRING][subject]
                signatures[subject_string] = base64.b64encode(
                    signature).decode('utf-8')
            trc_dict[SIGNATURES_STRING] = signatures
        trc_str = json.dumps(trc_dict, sort_keys=True, indent=4)
        return trc_str

    def pack(self, lz4_=False):
        ret = self.to_json().encode('utf-8')
        if lz4_:
            return lz4.dumps(ret)
        return ret

    def __str__(self):
        return self.to_json()

    def __eq__(self, other):  # pragma: no cover
        return str(self) == str(other)


def check_updated_TRC_validity(oldTRC, newTRC):
    """
    Check if update from current TRC to updated TRC is correct
    Only checks if update is correct! This function is called when signatures
    for the updated TRC are requested.

    :returns: True if update is correct, False otherwise
    """
    if oldTRC.isd != newTRC.isd:
        logging.error("TRC isdid mismatch")
        return False
    if oldTRC.version+1 != newTRC.version:
        logging.error("TRC versions mismatch")
        return False
    if newTRC.time < oldTRC.time:
        logging.error("new TRC timestamp is not valid")
        return False
    #TODO: Check: does this make sense?
    if not oldTRC.verify(oldTRC):
        logging.error("old/current TRC verification failed, missing or " + \
        "invalid signatures")
        return False
    return True


def verify_new_TRC(oldTRC, newTRC, neighborTRCs):
    """
    Check if update from current TRC to updated TRC is valid
    Assumes: neighborTRCs are valid

    :returns: True if update is valid, False otherwise
    """
    if not check_updated_TRC_validity(oldTRC, newTRC):
        logging.error("TRC update is not valid.")
        return False
    if not newTRC.verify(oldTRC):
        logging.error("new TRC verification failed, missing or " + \
        "invalid signatures")
        return False
    if not newTRC.verify_xsigs(neighborTRCs):
        logging.error("new TRC verification failed, missing or invalid" + \
        "cross signatures")
    logging.debug("New TRC verified")
    return True
