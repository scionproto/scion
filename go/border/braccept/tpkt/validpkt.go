package tpkt

import (
	"fmt"
	"hash"
	"net"

	"github.com/google/gopacket"

	"github.com/scionproto/scion/go/lib/common"
	"github.com/scionproto/scion/go/lib/hpkt"
	"github.com/scionproto/scion/go/lib/spkt"
)

var _ Packer = (*ValidPkt)(nil)
var _ Matcher = (*ValidPkt)(nil)

// ValidPkt behaves like PktMerge but it uses hpkt to build the packet instead of the custom
// building logic implemented by default.
// HPktInfo takes any other fields (AddrHdr, Path, etc.) from a base packet but uses hpkt
// to build the scion packet instead of the custom building logic implemented by the acceptance
// test.
// This means that the CmnHdr cannot be set in the test as it is generated by hpkt when building
// the packet based on its other fields (ie. AddrHdr, Path, Extensions, etc.)
// Basically, it creates a ScnPkt from the PktInfo in the test and calls hpkt.WriteScnPkt.
type ValidPkt struct {
	Pkt
}

// Generate a ScnPkt when use hpkt to build it
func (pi *ValidPkt) Pack(dstMac net.HardwareAddr, mac hash.Hash) (common.RawBytes, error) {
	// Complain if CmnHdr has been specified
	if pi.CmnHdr != nil {
		return nil, fmt.Errorf("PktInfoHpkt does not support custom CmnHdr")
	}
	if pi.L4 == nil {
		return nil, fmt.Errorf("PktInfoHpkt requires L4 header")
	}
	/*
		// Write SCION path
		pi.Path.Raw = make(common.RawBytes, pi.Path.Segs.Len())
		pi.Path.Mac = mac
		if _, err := pi.Path.WriteRaw(); err != nil {
			return nil, err
		}
	*/
	// Create ScnPkt
	scn := &spkt.ScnPkt{
		DstIA:   pi.AddrHdr.DstIA,
		SrcIA:   pi.AddrHdr.SrcIA,
		DstHost: pi.AddrHdr.DstHost,
		SrcHost: pi.AddrHdr.SrcHost,
		Path:    &pi.Path.Path,
		HBHExt:  pi.Exts, // XXX E2E are not supported yet
		L4:      pi.L4,
		Pld:     pi.Pld,
	}
	if scn.Pld == nil {
		scn.Pld = new(common.RawBytes)
	}
	// Make space in buffer
	scnLen := scn.TotalLen()
	buf := make(common.RawBytes, scnLen)
	_, err := hpkt.WriteScnPkt(scn, buf)
	if err != nil {
		return nil, err
	}
	overlayLayers, err := pi.GetOverlay(dstMac)
	if err != nil {
		return nil, err
	}
	l := make([]gopacket.SerializableLayer, len(overlayLayers)+1)
	for i := range overlayLayers {
		l[i] = overlayLayers[i]
	}
	l[len(overlayLayers)] = gopacket.Payload(buf)
	pkt := gopacket.NewSerializeBuffer()
	options := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}
	if err := gopacket.SerializeLayers(pkt, options, l...); err != nil {
		return nil, err
	}
	return common.RawBytes(pkt.Bytes()), nil
}

func (p *ValidPkt) GenCmnHdr() {
	// Do nothing
}

func (p *ValidPkt) Match(dev string, pkt gopacket.Packet) error {
	var b common.RawBytes
	var err error

	// Skip first Layer, Ethernet
	l := pkt.Layers()[1:]
	if l, err = p.Overlay.Check(l); err != nil {
		return err
	}
	// Generate common header
	p.CmnHdr = p.genCmnHdr()
	if _, err := p.Path.WriteRaw(); err != nil {
		return err
	}
	// Check Scion layers
	if b, err = p.checkScnHdr(l[0].LayerContents()); err != nil {
		return err
	}
	// TODO Check Extensions
	// Check L4 and Payload
	if b, err = p.checkL4(b); err != nil {
		return err
	}
	if b, err = p.checkPld(b); err != nil {
		return err
	}
	if len(b) > 0 {
		return fmt.Errorf("Unexpected traling bytes: %v", b)
	}
	// Expected packet matched!
	return nil
}
