// Copyright 2018 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tpkt

import (
	"github.com/google/gopacket"

	"github.com/scionproto/scion/go/lib/common"
	"github.com/scionproto/scion/go/lib/hpkt"
	"github.com/scionproto/scion/go/lib/l4"
	"github.com/scionproto/scion/go/lib/spkt"
)

var _ LayerBuilder = (*ValidScion)(nil)

// ValidScion uses hpkt to build the packet instead of the custom building logic implemented
// by default.
// This means that the CmnHdr cannot be set in the test as it is generated by hpkt when building
// the packet based on its other fields (ie. AddrHdr, Path, Extensions, etc.)
// Note that ValidScion deals with all the layers, except the overlay.
type ValidScion struct {
	AddrHdr *AddrHdr
	Path    *ScnPath
	Exts    []common.Extension
	L4      l4.L4Header
	Pld     common.Payload
}

func NewValidScion(srcIA, srcHost, dstIA, dstHost string, path *ScnPath, exts []common.Extension,
	l4Hdr l4.L4Header, pld common.Payload) *ValidScion {

	return &ValidScion{
		AddrHdr: NewAddrHdr(srcIA, srcHost, dstIA, dstHost),
		Path:    path,
		Exts:    exts,
		L4:      l4Hdr,
		Pld:     pld,
	}
}

func (p *ValidScion) Build() ([]gopacket.SerializableLayer, error) {
	// Create ScnPkt
	scn := &spkt.ScnPkt{
		DstIA:   p.AddrHdr.DstIA,
		SrcIA:   p.AddrHdr.SrcIA,
		DstHost: p.AddrHdr.DstHost,
		SrcHost: p.AddrHdr.SrcHost,
		Path:    &p.Path.Path,
		HBHExt:  p.Exts, // XXX E2E are not supported yet
		L4:      p.L4,
		Pld:     p.Pld,
	}
	if scn.Pld == nil {
		scn.Pld = &common.RawBytes{}
	}
	scnLen := scn.TotalLen()
	buf := make(common.RawBytes, scnLen)
	if _, err := hpkt.WriteScnPkt(scn, buf); err != nil {
		return nil, err
	}
	// From gopacket point of view, all these layers are seen as a single payload layer
	return []gopacket.SerializableLayer{gopacket.Payload(buf)}, nil
}
