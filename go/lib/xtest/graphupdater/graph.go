// Copyright 2018 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"io"
	"regexp"
	"sort"
	"strings"

	"github.com/scionproto/scion/go/lib/common"
)

var (
	ifaceRegexp = regexp.MustCompile(`(\d+-[\d:A-Fa-f]+)-?(\w+)?`)
)

type link struct {
	Src      iface  `yaml:"a"`
	Dst      iface  `yaml:"b"`
	LinkType string `yaml:"linkAtoB"`
}

type iface struct {
	ia    string
	iface string
}

func (i *iface) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}
	matches := ifaceRegexp.FindStringSubmatch(s)
	if len(matches) < 3 || len(matches[1]) == 0 {
		return common.NewBasicError("Invalid interface", nil, "s", s)
	}
	iface := matches[2]
	if len(iface) == 0 {
		iface = DfltIface
	}
	i.ia = matches[1]
	i.iface = iface
	return nil
}

func (i iface) IsEmpty() bool {
	return i.ia == "" && i.iface == ""
}

func (i iface) Name() string {
	parts := strings.Split(i.ia, ":")
	return fmt.Sprintf("%s_%s", parts[len(parts)-1], i.iface)
}

type Graph struct {
	sortedIfaces []iface
	IfaceIds     map[iface]int
	links        []link
}

func newGraph(links []link, staticIfaceIds map[string]int) *Graph {
	ifaces, links := extractIfaces(links)
	ifaces = sortIfaces(ifaces)
	g := &Graph{
		sortedIfaces: ifaces,
		IfaceIds:     generateIfaceIds(ifaces, staticIfaceIds),
		links:        links,
	}
	return g
}

func (g *Graph) Write(w io.Writer) (int, error) {
	total := 0
	lines := []string{
		"// Code generated by graphupdater tool, DO NOT EDIT.",
		"package graph",
		"import (",
		`"github.com/scionproto/scion/go/lib/common"`,
		")",
		fmt.Sprintf("var (\n%s\n)\n", strings.Join(g.staticIfaceIdMapping(), "\n")),
		fmt.Sprintf("var (\n%s\n)\n", strings.Join(g.interfaces(), "\n")),
		"var DefaultGraphDescription = &Description{",
		fmt.Sprintf("Nodes: []string{\n%v\n},", strings.Join(g.nodes(), "\n")),
		fmt.Sprintf("Edges: []EdgeDesc{\n%v\n},", strings.Join(g.edges(), "\n")),
		"}",
	}
	n, err := w.Write([]byte(strings.Join(lines, "\n")))
	total += n
	if err != nil {
		return total, err
	}
	return total, nil
}

func (g *Graph) nodes() []string {
	var curIa string
	var node string
	var res []string
	for _, iface := range g.sortedIfaces {
		id := g.IfaceIds[iface]
		if curIa == "" || curIa != iface.ia {
			if node != "" {
				res = append(res, node)
			}
			curIa = iface.ia
			node = fmt.Sprintf("\"%s\", // %s = %v", iface.ia, iface.iface, id)
		} else {
			node = fmt.Sprintf("%s, %s = %d", node, iface.iface, id)
		}
	}
	res = append(res, node)
	return res
}

func (g *Graph) edges() []string {
	res := make([]string, 0, len(g.links))
	for _, l := range g.links {
		sd := g.ifaceName(l.Src, l.Dst)
		ds := g.ifaceName(l.Dst, l.Src)
		edge := fmt.Sprintf(`{"%s", %s, "%s", %s, %v},`, l.Src.ia, sd,
			l.Dst.ia, ds, l.LinkType == "PEER")
		res = append(res, edge)
	}
	return res
}

func (g *Graph) interfaces() []string {
	var res []string
	seen := make(map[string]struct{})
	for _, l := range g.links {
		srcI := g.IfaceIds[l.Src]
		dstI := g.IfaceIds[l.Dst]
		ifVar := fmt.Sprintf("%s = common.IFIDType(%d%d)", g.ifaceName(l.Src, l.Dst), srcI, dstI)
		if _, ok := seen[ifVar]; !ok {
			res = append(res, ifVar)
			seen[ifVar] = struct{}{}
		}
		ifVar = fmt.Sprintf("%s = common.IFIDType(%d%d)", g.ifaceName(l.Dst, l.Src), dstI, srcI)
		if _, ok := seen[ifVar]; !ok {
			res = append(res, ifVar)
			seen[ifVar] = struct{}{}
		}
	}
	return res
}

func (g *Graph) staticIfaceIdMapping() []string {
	res := []string{
		"StaticIfaceIdMapping = map[string]int{",
	}
	for _, iface := range g.sortedIfaces {
		res = append(res, fmt.Sprintf(`"%s": %d,`, iface.Name(), g.IfaceIds[iface]))
	}
	res = append(res, "}")
	return res
}

func (g *Graph) ifaceName(src, dst iface) string {
	return fmt.Sprintf("If_%s_%s", src.Name(), dst.Name())
}

func extractIfaces(links []link) ([]iface, []link) {
	seen := make(map[iface]struct{})
	seenLinks := make(map[link]int)
	var res []iface
	var linkRes []link
	for _, l := range links {
		if _, ok := seen[l.Src]; !ok {
			seen[l.Src] = struct{}{}
			res = append(res, l.Src)
		}
		if _, ok := seen[l.Dst]; !ok {
			seen[l.Dst] = struct{}{}
			res = append(res, l.Dst)
		}
		// the graph does not allow multiple edges between 2 nodes,
		// so increment
		if v, ok := seenLinks[l]; !ok {
			seenLinks[l] = 1
			linkRes = append(linkRes, l)
		} else {
			seenLinks[l] = v + 1
			src := l.Src
			src.iface = fmt.Sprintf("%s%d", src.iface, v)
			res = append(res, src)
			linkRes = append(linkRes, link{
				Src:      src,
				Dst:      l.Dst,
				LinkType: l.LinkType,
			})
		}
	}
	return res, linkRes
}

func sortIfaces(ifaces []iface) []iface {
	sort.Slice(ifaces, func(i, j int) bool {
		iaOrder := strings.Compare(ifaces[i].ia, ifaces[j].ia)
		if iaOrder != 0 {
			return iaOrder < 0
		}
		// ia same, return DflIface first then order of ifaces.
		return ifaces[i].iface == DfltIface ||
			(ifaces[j].iface != DfltIface && strings.Compare(ifaces[i].iface, ifaces[j].iface) < 0)
	})
	return ifaces
}

func generateIfaceIds(ifaces []iface, staticIfaceId map[string]int) map[iface]int {
	res := make(map[iface]int, len(ifaces))
	i := maxVal(staticIfaceId) + 1
	for _, iface := range ifaces {
		if fixedVal, ok := staticIfaceId[iface.Name()]; ok {
			res[iface] = fixedVal
		} else {
			res[iface] = i
			i++
		}
	}
	return res
}

func maxVal(m map[string]int) int {
	max := 9
	for _, v := range m {
		if v > max {
			max = v
		}
	}
	return max
}
