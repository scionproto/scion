package pkti

import (
	"fmt"
	"hash"
	"net"

	"github.com/google/gopacket"

	"github.com/scionproto/scion/go/lib/common"
	"github.com/scionproto/scion/go/lib/hpkt"
	"github.com/scionproto/scion/go/lib/spkt"
)

var _ PktGen = (*HpktInfo)(nil)
var _ PktMatch = (*HpktInfo)(nil)

// HpktInfo behaves like PktMerge but it uses hpkt to build the packet instead of the custom
// building logic implemented by default.
// HPktInfo takes any other fields (AddrHdr, Path, etc.) from a base packet but uses hpkt
// to build the scion packet instead of the custom building logic implemented by the acceptance
// test.
// This means that the CmnHdr cannot be set in the test as it is generated by hpkt when building
// the packet based on its other fields (ie. AddrHdr, Path, Extensions, etc.)
// Basically, it creates a ScnPkt from the PktInfo in the test and calls hpkt.WriteScnPkt.
type HpktInfo struct {
	PktInfo
}

// Generate a ScnPkt when use hpkt to build it
func (pi *HpktInfo) Pack(dstMac net.HardwareAddr, mac hash.Hash) (common.RawBytes, error) {
	// Complain if CmnHdr has been specified
	if pi.CmnHdr != nil {
		return nil, fmt.Errorf("PktInfoHpkt does not support custom CmnHdr")
	}
	if pi.L4 == nil {
		return nil, fmt.Errorf("PktInfoHpkt requires L4 header")
	}
	// Write SCION path
	pi.Path.Raw = make(common.RawBytes, pi.Path.Segs.Len())
	pi.Path.Mac = mac
	if _, err := pi.Path.WriteRaw(); err != nil {
		return nil, err
	}
	// Create ScnPkt
	scn := &spkt.ScnPkt{
		DstIA:   pi.AddrHdr.DstIA,
		SrcIA:   pi.AddrHdr.SrcIA,
		DstHost: pi.AddrHdr.DstHost,
		SrcHost: pi.AddrHdr.SrcHost,
		Path:    &pi.Path.Path,
		HBHExt:  pi.Exts, // XXX E2E are not supported yet
		L4:      pi.L4,
		Pld:     pi.Pld,
	}
	if scn.Pld == nil {
		scn.Pld = new(common.RawBytes)
	}
	// Make space in buffer
	scnLen := scn.TotalLen()
	buf := make(common.RawBytes, scnLen)
	_, err := hpkt.WriteScnPkt(scn, buf)
	if err != nil {
		return nil, err
	}
	overlayLayers, err := pi.GetOverlay(dstMac)
	if err != nil {
		return nil, err
	}
	l := make([]gopacket.SerializableLayer, len(overlayLayers)+1)
	for i, _ := range overlayLayers {
		l[i] = overlayLayers[i]
	}
	l[len(overlayLayers)] = gopacket.Payload(buf)
	pkt := gopacket.NewSerializeBuffer()
	options := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}
	if err := gopacket.SerializeLayers(pkt, options, l...); err != nil {
		return nil, err
	}
	return common.RawBytes(pkt.Bytes()), nil
}

func (p *HpktInfo) Setup() {
	// Do nothing
}
