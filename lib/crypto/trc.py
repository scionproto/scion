# Copyright 2014 ETH Zurich
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
:mod:`trc` --- SCION TRC parser
===============================================
"""
# Stdlib
import base64
import copy
import json
import logging
import time

# External
import lz4

# SCION
from lib.crypto.asymcrypto import verify
from lib.crypto.certificate import (
    Certificate,
    SUBJECT_ENC_KEY_STRING,
    SUBJECT_SIG_KEY_STRING,
    SIGNATURE_STRING
)
from lib.packet.scion_addr import ISD_AS

ISDID_STRING = 'ISDID'
VERSION_STRING = 'Version'
TIME_STRING = 'Time'
CORE_ASES_STRING = 'CoreCAs'
ROOT_CAS_STRING = 'RootCAs'
LOGS_STRING = 'Logs'
CA_THRESHOLD_STRING = 'CAThreshold'
ROOT_DNS_SERVERS_STRING = 'RootDNSServers'
ROOT_DNS_CERT_STRING = 'RootDNSCert'
QUORUM_OWN_TRC_STRING = 'QuorumOwnTRC'
QUORUM_CAS_STRING = 'QuorumCAs'
QUROUM_DNS_STRING = 'QuorumDNS'
QUARANTINE_STRING = 'Quarantine'
SIGNATURES_STRING = 'Signatures'
GRACE_PERIOD_STRING = 'GracePeriod'


class TRC(object):
    """
    The TRC class parses the TRC file of an ISD and stores such
    information for further use.

    :ivar int isd: the ISD identifier.
    :ivar int version: the TRC file version.
    :ivar int time: the TRC file creation timestamp.
    :ivar dict core_ases: the set of core ASes and their certificates.
    :ivar dict root_cas: the set of root CAs and their certificates.
    :ivar dict logs: is a dictionary of end entity certificate logs, and
        their addresses and public key certificates
    :ivar int ca_threshold: is a threshold number (nonnegative integer) of
        CAs that have to sign a domainâ€™s policy
    :ivar str root_dns_server_addr: the root DNS server's address.
    :ivar str root_dns_server_cert: the root DNS server's certificate.
    :ivar int quorum_own_trc: number of core ASes necessary to sign a new TRC.
    :ivar int quorum_cas: number of CAs necessary to change CA entries
    :ivar int quorum_dns: number of DNS entities necessary to change DNS entries
    :ivar int grace_period: defines for how long this TRC is valid when a new
        TRC is available
    :ivar bool quarantine: TRC valid?
    :ivar dict signatures: signatures generated by a quorum of trust roots.
    """

    def __init__(self, trc_raw=None, lz4_=False):
        """
        :param str trc_raw: TRC as json string.
        """
        self.isd = 0
        self.version = 0
        self.time = 0
        self.core_ases = {}
        self.root_cas = {}
        self.logs = {}
        self.ca_threshold = 0
        self.root_dns_server_addr = ''
        self.root_dns_server_cert = ''
        self.quorum_own_trc = 0
        self.quorum_cas = 0
        self.quorum_dns = 0
        self.grace_period = 0
        self.quarantine = False
        self.signatures = {}
        if trc_raw:
            self._parse(trc_raw, lz4_)

    def get_isd_ver(self):
        return self.isd, self.version

    def get_core_ases(self):
        res = []
        for key in self.core_ases:
            res.append(ISD_AS(key))
        return res

    def get_trc_dict(self, with_signatures):
        """
        Return the TRC information.

        :param bool with_signatures:
            If True, include signatures in the return value.
        :returns: the TRC information.
        :rtype: dict
        """
        trc_dict = {
            ISDID_STRING: self.isd,
            VERSION_STRING: self.version,
            TIME_STRING: self.time,
            CORE_ASES_STRING: self.core_ases,
            ROOT_CAS_STRING: self.root_cas,
            LOGS_STRING: self.logs,
            CA_THRESHOLD_STRING: self.ca_threshold,
            ROOT_DNS_SERVERS_STRING: self.root_dns_server_addr,
            ROOT_DNS_CERT_STRING: self.root_dns_server_cert,
            QUORUM_OWN_TRC_STRING: self.quorum_own_trc,
            QUORUM_CAS_STRING: self.quorum_cas,
            QUROUM_DNS_STRING: self.quorum_dns,
            GRACE_PERIOD_STRING: self.grace_period,
            QUARANTINE_STRING: self.quarantine}
        if with_signatures:
            trc_dict[SIGNATURES_STRING] = self.signatures
        return trc_dict

    def _parse(self, trc_raw, lz4_):
        """
        Parse a TRC file and populate the instance's attributes.

        :param str trc_raw: TRC as json string.
        """
        if lz4_:
            trc_raw = lz4.loads(trc_raw).decode("utf-8")
        trc = json.loads(trc_raw)
        self.isd = trc[ISDID_STRING]
        self.version = trc[VERSION_STRING]
        self.time = trc[TIME_STRING]
        for subject in trc[CORE_ASES_STRING]:
            cert_dict = base64.b64decode(trc[CORE_ASES_STRING][subject]).\
                decode('utf-8')
            cert_dict = json.loads(cert_dict)
            cert_dict[SUBJECT_SIG_KEY_STRING] = base64.b64decode(
                cert_dict[SUBJECT_SIG_KEY_STRING])
            cert_dict[SUBJECT_ENC_KEY_STRING] = base64.b64decode(
                cert_dict[SUBJECT_ENC_KEY_STRING])
            cert_dict[SIGNATURE_STRING] =\
                base64.b64decode(cert_dict[SIGNATURE_STRING])
            isd_, as_ = self._get_isdid_asid_from_string_trc_file(subject)
            self.core_ases[isd_ + '-' + as_] = Certificate.from_dict(cert_dict)
        self.root_cas = trc[ROOT_CAS_STRING]
        self.logs = trc[LOGS_STRING]
        self.ca_threshold = trc[CA_THRESHOLD_STRING]
        self.root_dns_server_addr = trc[ROOT_DNS_SERVERS_STRING]
        self.root_dns_server_cert = trc[ROOT_DNS_CERT_STRING]
        self.quorum_own_trc = trc[QUORUM_OWN_TRC_STRING]
        self.quorum_cas = trc[QUORUM_CAS_STRING]
        self.quorum_dns = trc[QUROUM_DNS_STRING]
        self.grace_period = trc[GRACE_PERIOD_STRING]
        self.quarantine = trc[QUARANTINE_STRING]
        for subject in trc[SIGNATURES_STRING]:
            isd_, as_ = self._get_isdid_asid_from_string_trc_file(subject)
            self.signatures[isd_ + '-' + as_] = \
                base64.b64decode(trc[SIGNATURES_STRING][subject])

    @classmethod
    def from_values(cls, isd, version, core_ases, root_cas, logs, ca_threshold,
                    root_dns_server_addr, root_dns_server_cert, quorum_own_trc,
                    quorum_cas, quorum_dns, quarantine, signatures,
                    grace_period):
        """
        Generate a TRC instance.
        """
        trc = TRC()
        trc.isd = isd
        trc.version = version
        trc.time = int(time.time())
        trc.core_ases = core_ases
        trc.root_cas = root_cas
        trc.logs = logs
        trc.ca_threshold = ca_threshold
        trc.root_dns_server_addr = root_dns_server_addr
        trc.root_dns_server_cert = root_dns_server_cert
        trc.quorum_own_trc = quorum_own_trc
        trc.quorum_cas = quorum_cas
        trc.quorum_dns = quorum_dns
        trc.grace_period = grace_period
        trc.quarantine = quarantine
        trc.signatures = signatures
        return trc

    def verify(self, oldTRC):
        """
        Perform signature verification.

        :returns: True if verification succeeds, false otherwise
        """
        return self._verify_core_signatures(oldTRC)

    def _verify_core_signatures(self, oldTRC):
        """
        Perform signature verification for core signatures.

        :returns: True if verification succeeds, false otherwise.
        :rtype: bool
        """
        # only look at signatures which are from core ASes
        signatures = {k: self.signatures[k] for k in oldTRC.core_ases.keys()}
        if len(signatures) < len(self.signatures):
            logging.warning("TRC is signed by a non-core AS")
        valid_signature_signers = set()
        for signer in signatures:
            public_key = self.core_ases[signer].subject_sig_key
            if self._verify_signature(signatures[signer], public_key):
                valid_signature_signers.add(signer)
        if len(valid_signature_signers) < self.quorum_own_trc:
            logging.error("TRC does not have the number of required valid \
            signatures. Required Signatures:%s, valid signatures:%s" % (
                self.quorum_own_trc,
                len(valid_signature_signers)))
            logging.error(valid_signature_signers)
            return False
        if len(valid_signature_signers) < oldTRC.quorum_own_trc:
            logging.error("TRC does not have the number of required valid \
            signatures as defined in old TRC. \
            Required Signatures:%s, valid signatures:%s" % (
                oldTRC.quorum_own_trc,
                len(valid_signature_signers)))
            return False
        return True

    def _verify_signature(self, signature, public_key):
        """
        Checks if the signature can be verified with the given public key
        """
        msg = self.to_json(with_signatures=False).encode('utf-8')
        if not verify(msg, signature, public_key):
            return False
        return True

    def to_json(self, with_signatures=True):
        """
        Convert the instance to json format.
        """
        trc_dict = copy.deepcopy(self.get_trc_dict(with_signatures))
        core_ases = {}
        for subject in trc_dict[CORE_ASES_STRING]:
            isd_, as_ = self.get_isdid_asid_from_string(subject)
            subject_string = self._create_subject_string(isd_, as_)
            cert_str = str(trc_dict[CORE_ASES_STRING][subject])
            core_ases[subject_string] = base64.b64encode(
                cert_str.encode('utf-8')).decode('utf-8')
        trc_dict[CORE_ASES_STRING] = core_ases
        if with_signatures:
            signatures = {}
            for subject in trc_dict[SIGNATURES_STRING]:
                isd_, as_ = self.get_isdid_asid_from_string(subject)
                subject_string = self._create_subject_string(isd_, as_)
                signature = trc_dict[SIGNATURES_STRING][subject]
                signatures[subject_string] = base64.b64encode(
                    signature).decode('utf-8')
            trc_dict[SIGNATURES_STRING] = signatures
        trc_str = json.dumps(trc_dict, sort_keys=True, indent=4)
        return trc_str

    def _create_subject_string(self, isd_, as_):
        """
        Helper function to create a string consistent with TRC file
        out of isdid and asid.
        """
        return '{ISDID: ' + str(isd_) + ', ASID: ' + str(as_) + '}'

    def _get_isdid_asid_from_string_trc_file(self, subject):
        """
        Helper function to parse string which encodes isdid and asid
        in the format "{ISDID: isdid, ASID: asid}". This format is used in
        TRC files.

        :returns: isdid, asid
        :rtype: pair of ints
        """
        isd_, as_ = subject.split(' ', 1)[1].split(',', 1)
        as_ = as_.split(' ', 2)[2].split('}', 1)[0]
        return (isd_, as_)

    def get_isdid_asid_from_string(self, subject):
        """
        Helper function to parse string which encodes isdid and asid
        in the format "isdid-asid"
        """
        isd_, as_ = subject.split("-", 1)
        return (isd_, as_)

    def pack(self, lz4_=False):
        ret = self.to_json().encode('utf-8')
        if lz4_:
            return lz4.dumps(ret)
        return ret

    def __str__(self):
        return self.to_json()

    def __eq__(self, other):  # pragma: no cover
        return str(self) == str(other)


def check_updated_TRC_validity(oldTRC, newTRC):
    """
    Check if update from current TRC to updated TRC is correct
    Only checks if update is correct! This function is called when signatures
    for the updated TRC are requested.

    :returns: True if update is correct, False otherwise
    """
    if oldTRC.isd != newTRC.isd:
        logging.error("TRC isdid mismatch")
        return False
    if oldTRC.version+1 != newTRC.version:
        logging.error("TRC versions mismatch")
        return False
    if newTRC.time < oldTRC.time:
        logging.error("New TRC timestamp is not valid")
        return False
    return True


def verify_new_TRC(oldTRC, newTRC):
    """
    Check if update from current TRC to updated TRC is valid

    :returns: True if update is valid, False otherwise
    """
    if not check_updated_TRC_validity(oldTRC, newTRC):
        logging.error("TRC update is not valid.")
        return False
    if not newTRC.verify(oldTRC):
        logging.error("New TRC verification failed, missing or \
        invalid signatures")
        return False
    logging.debug("New TRC verified")
    return True
