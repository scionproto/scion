#!/usr/bin/env python3

# Copyright 2019 Anapaya Systems
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import logging
import time
from copy import deepcopy
from typing import Dict, List

from plumbum.cmd import (
    cp,
    mkdir,
)
from plumbum import local
from plumbum.path.local import LocalPath

from acceptance.common.log import LogExec, init_log
from acceptance.common.base import CmdBase, set_name, TestBase, TestState
from acceptance.common.scion import SCIONDocker
from acceptance.common.tools import DC

set_name(__file__)
logger = logging.getLogger(__name__)


class Test(TestBase):
    """
    Test that an interface can be added to the topology and the beacon server
    starts beaconing on that interface.

    In the setup phase, the tiny topology is started with the link between
    1-ff00:0:110 and 1-ff00:0:111 missing from the topology of the beacon
    servers.

    In the run phase, we first check that the end2end connectivity is broken.
    Then we set the topology containing the link and send a reload signal to the
    control services. After some time that allows for beacon propagation, the
    test checks that end2end connectivity is established.
    """


def find_cs_configs() -> List[LocalPath]:
    """
    Return the paths to the cs  config files in AS 1-ff00:0:110 and 1-ff00:0:111.
    """
    return local.path('gen') // 'ASff00_0_11[0,1]/cs*.toml'


@Test.subcommand('setup')
class TestSetup(CmdBase):
    """ Setup topology with missing link between 1-ff00:0:110 and 1-ff00:0:111. """
    @LogExec(logger, 'setup')
    def main(self):
        self.cmd_setup()
        self.scion.topology('topology/tiny.topo')
        self.modify_topologies()
        self.scion.run()
        if not self.no_docker:
            self.tools_dc('start', 'tester*')
            self.docker_status()

    def modify_topologies(self):
        cs_configs = find_cs_configs()
        cs_dirs = self.copy_cs_configs(cs_configs)

        topos = self.load_topologies(cs_dirs)
        filtered = self.filter_interfaces(topos, ['1-ff00:0:110', '1-ff00:0:111'])
        self.dump_topologies(filtered)

    def copy_cs_configs(self, cs_configs):
        """
        Copy configuration files shared between the different services (topology.json, crypto/, ..)
        into separate subdirectory for the CS, it is "unshared" and can be modified without
        affecting the other services (routers, sciond, ...).
        :returns: new subdirectories for CS configs
        """
        cs_dirs = []
        for cs_config in cs_configs:
            self.scion.set_configs({'general.config_dir': '/share/conf/%s/' % cs_config.stem},
                                   [cs_config])
            base = cs_config.parent
            cs_dir = base / cs_config.stem
            cs_dirs.append(cs_dir)
            mkdir(cs_dir)
            srcs = [base / n for n in ['crypto', 'keys', 'certs', 'topology.json']]
            cp('-r', *srcs, cs_dir)

        return cs_dirs

    @staticmethod
    def load_topologies(cs_dirs: List[LocalPath]) -> Dict[str, Dict]:

        files = [cs_dir / 'topology.json' for cs_dir in cs_dirs]
        topos = {}
        for file in files:
            logger.debug('loading topology: %s', file)
            with open(file, 'r') as f:
                topos[file] = json.load(f)
        return topos

    @staticmethod
    def filter_interfaces(topos: Dict[str, Dict], ia: List[str]) -> Dict[str, Dict]:
        """ Filter all interfaces in all topologies that link to an interface in ia. """
        t = deepcopy(topos)
        for fn, topo in topos.items():
            for br_name, br_dict in topo['border_routers'].items():
                for intf_id, intf_dict in br_dict['interfaces'].items():
                    if intf_dict['isd_as'] in ia:
                        logging.debug('filtering interface %s:%s' % (br_name, intf_id))
                        del t[fn]['border_routers'][br_name]['interfaces'][intf_id]
        return t

    @staticmethod
    def dump_topologies(topos: Dict[str, Dict]):
        for fn, topo in topos.items():
            logger.debug('dumping topology: %s', fn)
            with open(fn, 'w') as f:
                json.dump(topo, f)


@Test.subcommand('run')
class TestRun(CmdBase):
    """ Run the test. """

    @LogExec(logger, 'run')
    def main(self):
        self.scion.run_end2end(expect_fail=True)
        logger.info('Initial end2end failed as expected, restoring topologies')
        cs_configs = find_cs_configs()
        self.restore_topologies(cs_configs)
        names = [cs_config.stem for cs_config in cs_configs]
        logging.info('Reloading services: %s' % names)
        self.scion.reload_svc(names)
        time.sleep(2)
        self.scion.run_end2end()

    @staticmethod
    def restore_topologies(cs_configs: List[LocalPath]):
        """
        Copy unmodified topology.json file from shared AS directory and overwrite the
        modified file in the CS's config subdirectory.
        """
        for cs_config in cs_configs:
            cp(cs_config.parent / 'topology.json', cs_config.parent / cs_config.stem)


if __name__ == '__main__':
    init_log()
    Test.test_state = TestState(SCIONDocker(), DC(''))
    Test.run()
