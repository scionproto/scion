// Copyright 2025 Anapaya Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package control

import (
	"context"
	"fmt"

	"github.com/scionproto/scion/control/beacon"
	"github.com/scionproto/scion/control/beaconing"
	"github.com/scionproto/scion/control/ifstate"
	seg "github.com/scionproto/scion/pkg/segment"

	"github.com/scionproto/scion/pkg/private/serrors"
)

type SegmentRegistrationPlugin interface {
	// ID returns the unique identifier of the plugin.
	ID() string
	// New creates a new instance of the plugin with the provided configuration.
	New(
		ctx context.Context,
		t *TasksConfig,
		config map[string]any,
	) (SegmentRegistrar, error)
	// Validate validates the configuration of the plugin.
	Validate(config map[string]any) error
}

type SegmentRegistrar interface {
	// RegisterSegments registers the given segments with the given type according
	// to the plugin's logic.
	RegisterSegments(
		ctx context.Context,
		segmentType seg.Type,
		policyType beacon.PolicyType,
		segments []beacon.Beacon,
	) (RegistrationStats, error)
}

type SegmentRegistrars map[beacon.PolicyType]map[string]SegmentRegistrar

func (s SegmentRegistrars) Register(
	policyType beacon.PolicyType, registrationPolicy string, registrar SegmentRegistrar,
) error {
	if _, ok := s[policyType]; !ok {
		s[policyType] = make(map[string]SegmentRegistrar)
	}
	if _, ok := s[policyType][registrationPolicy]; ok {
		return serrors.New("registrar already registered for policy type and registration policy",
			"policy_type", policyType, "registration_policy", registrationPolicy)
	}
	s[policyType][registrationPolicy] = registrar
	return nil
}

func (s SegmentRegistrars) Get(
	policyType beacon.PolicyType, registrationPolicy string,
) (SegmentRegistrar, error) {
	if _, ok := s[policyType]; !ok {
		return nil, serrors.New("no registrars found for policy type",
			"policy_type", policyType)
	}
	registrar, ok := s[policyType][registrationPolicy]
	if !ok {
		return nil, serrors.New("no registrar found for registration policy",
			"registration_policy", registrationPolicy, "policy_type", policyType)
	}
	return registrar, nil
}

type RegistrationStats struct {
	// Status contains the registration status for each segment.
	// The key is the segment ID, generated by seg.PathSegment.FullID().
	// If the segment was successfully registered, the error is nil.
	Status map[string]error
}

// SegmentRegistrationPlugins is a global map of registered segment registration plugins.
var SegmentRegistrationPlugins = map[string]SegmentRegistrationPlugin{}

func RegisterPlugin(p SegmentRegistrationPlugin) {
	id := p.ID()
	if _, ok := SegmentRegistrationPlugins[id]; ok {
		panic(fmt.Sprintf("plugin %q already registered", id))
	}
	SegmentRegistrationPlugins[id] = p
}

type DefaultSegmentRegistrationPlugin struct{}

var _ SegmentRegistrationPlugin = (*DefaultSegmentRegistrationPlugin)(nil)

func (p *DefaultSegmentRegistrationPlugin) ID() string {
	return "default"
}

func (p *DefaultSegmentRegistrationPlugin) New(
	ctx context.Context,
	t *TasksConfig,
	config map[string]any,
) (SegmentRegistrar, error) {
	return &DefaultSegmentRegistrar{}, nil
}

func (p *DefaultSegmentRegistrationPlugin) Validate(
	config map[string]any,
) error {
	// Default plugin does not have any configuration.
	return nil
}

type DefaultSegmentRegistrar struct {
	Intfs    *ifstate.Interfaces
	Extender beaconing.Extender
}

func (r *DefaultSegmentRegistrar) RegisterSegments(
	ctx context.Context,
	segmentType seg.Type,
	policyType beacon.PolicyType,
	segments []beacon.Beacon,
) (RegistrationStats, error) {
	// TODO: Implement.

	// if segType is Up or Core (!= Down), register locally and otherwise register remotely.
	return RegistrationStats{}, nil
}
